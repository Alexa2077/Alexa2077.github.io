[{"title":"github+Hexo免费构建个人网站","date":"2025-05-30T09:14:29.000Z","url":"/2025/05/30/github-Hexo%E5%85%8D%E8%B4%B9%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","tags":[["Hexo","/tags/Hexo/"],["github","/tags/github/"],["个人网站","/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"]],"categories":[[" ",""]],"content":"Hexo 是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo + GitHub 文章发布原理 主要分为以下几个步骤： 1，hexo环境搭建； 2，github部署； 3，网站配置； 4，发表第一篇blog； 1 hexo环境搭建1.1 环境准备Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。 Node.js： Git： 下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。 1.2 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 如果是mac用户，前面加上 sudo： 1.3 初始化博客安装 Hexo 完成后，你可以新建一个文件夹来存放hexo的程序文件，如hexo-blog； 然后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 新建完成后，指定文件夹的目录如下： 1.4 本地预览完成后依次输入下面命令，启动本地服务器进行预览： 该命令也可以简写为： 完成生成过后即可执行下列命令，在本地开启服务。 该命令也可以简写为： 访问 &lt;font style=&quot;color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);&quot;&gt;;，出现 Hexo 默认页面，本地博客安装成功！ 2 Github部署部署 Hexo 到 GitHub Pages，本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 2.1 配置git打开 Terminal，取消 ssl 认证： 设置 user.name 和 user.email 配置信息： 生成 ssh 密钥文件： 然后直接三个回车即可，默认不需要设置密码。你应该会看到如下输出： 在C:\\Users\\用户名&#x2F;.ssh&#x2F;id_rsa.pub处找到生成的id_rsa.pub 密钥，复制其中全部内容。 2.2 配置github使用邮箱注册 GitHub 帐号并登录； 点击右上角加号图标，选择 New repository 创建一个新仓库，仓库名为：用户名.github.io，该 用户名 使用自己的 GitHub 帐号名称代替。 打开 GitHub_Settings_keys 页面，点击 New SSH key 按钮，Title 处为本台计算机取一个名字，然后将刚刚复制的 id_rsa.pub 内容粘贴进去，最后点击 Add SSH key。 2.3 配置hexo打开 blog 根目录里的_config.yml文件，也称为 站点配置文件。 在站点配置文件的最后，修改为如下形式并保存： 打开 Terminal 安装 Git 部署插件： 2.4 部署博客到 Github Page输入以下命令完成生成与部署： 完成后打开浏览器，在地址栏输入博客所在仓库的路径，即 “http:&#x2F;&#x2F;用户名.github.io”，即可通过互联网访问生成的博客。 3 网站配置打开 blog 根目录里的_config.yml文件，也称为 站点配置文件。下面只介绍一些必要的选项： 根据自己的博客需要更改设置。 3.1 网站 参数 描述 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;title&lt;/font&gt; 网站标题 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;subtitle&lt;/font&gt; 网站副标题 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;description&lt;/font&gt; 网站描述 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;keywords&lt;/font&gt; 网站的关键词。支持多个关键词。 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;author&lt;/font&gt; 您的名字 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;language&lt;/font&gt; 网站使用的语言。 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;timezone&lt;/font&gt; 网站时区。Hexo 默认使用您电脑的时区。 3.2 写作默认不需要更改。 参数 描述 默认值 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;new_post_name&lt;/font&gt; 新文章的文件名称 :title.md &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;default_layout&lt;/font&gt; 预设布局 post &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;titlecase&lt;/font&gt; 把标题转换为 title case false &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;external_link&lt;/font&gt; 在新标签中打开链接 true &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;external_link.enable&lt;/font&gt; 在新标签中打开链接 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;true&lt;/font&gt; &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;external_link.field&lt;/font&gt; 对整个网站（&lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;site&lt;/font&gt;）生效或仅对文章（&lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;post&lt;/font&gt;）生效 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;site&lt;/font&gt; &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;external_link.exclude&lt;/font&gt; 需要排除的域名。主域名和子域名如 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;www&lt;/font&gt; 需分别配置 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;[]&lt;/font&gt; &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;filename_case&lt;/font&gt; 把文件名称转换为 (1) 小写或 (2) 大写 0 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;render_drafts&lt;/font&gt; 显示草稿 false &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;post_asset_folder&lt;/font&gt; 启动 Asset 文件夹 false &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;relative_link&lt;/font&gt; 把链接改为与根目录的相对位址 false &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;future&lt;/font&gt; 显示未来的文章 true &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;highlight&lt;/font&gt; 代码块的设置, 请参考 Highlight.js 进行设置 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;prismjs&lt;/font&gt; 代码块的设置, 请参考 PrismJS 进行设置 3.3 主题配置Hexo 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换。 这里以 Card 主题为例。详细配置方法可以参考 Theme Cards 参考手册。 可以使用 Git 拉取「Cards」，以后还可以使用 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;git pull&lt;/font&gt; 直接更新「Cards」。在站点根目录打开终端，并执行： 在站点配置文件中，将 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;theme&lt;/font&gt; 的值改为 &lt;font style=&quot;color:rgb(76, 77, 78);background-color:rgb(238, 238, 238);&quot;&gt;cards&lt;/font&gt;。 如果获取「Cards」时你将文件夹重命名为其他名字，请将 &lt;font style=&quot;color:rgb(106, 115, 125);background-color:rgb(238, 238, 238);&quot;&gt;cards&lt;/font&gt; 对应为你重命名文件夹的名字。 4 发布第一篇blog常用指令 4.1 创建博客： 创建成功后，博客位于 &#x2F;source&#x2F;_post 打开该博客之后可以看到： 本地启动进行预览： 浏览器访问 ： 4.2 管理图片一篇情况下，需要在source下面新建image文件夹，进行放置图片，但是如果未来图片的数据增加，不好引用，不方便管理。那我们可以采用下面的方式： 如下修改 Hexo 博客目录中的 _config.yml，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。 执行如下命令创建一篇新文章，名为test1 执行完成后在source_posts目录下生成了一个md文件和一个同名的资源目录(用于存放图片) 我们在test文件夹下面放一张图片 image.png 在test1.md中添加内容如下，演示了图片的引用方式。本文主要markdown语法： 这种方式的缺点就是，无法在markdwon里面展示，但是可以在web界面上展示： 本地启动： 浏览器访问 ，页面如下，文章添加成功 参考：  "},{"title":"影像组学Radiomics","date":"2025-05-30T07:59:21.000Z","url":"/2025/05/30/%E5%BD%B1%E5%83%8F%E7%BB%84%E5%AD%A6Radiomics/","tags":[["医学图像","/tags/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/"],["影像组学","/tags/%E5%BD%B1%E5%83%8F%E7%BB%84%E5%AD%A6/"]],"categories":[[" ",""]],"content":"1 影像组学介绍其实就是想把图像处理领域的知识点，应用到医学图像里面。当初影像组学方法是，现在人工智能方法也是。 随着精准定量医学影像技术的快速发展、图像识别技术和数据算法的不断更新，医学图像大数据的挖掘和分析得以实现，极大程度扩展了医学图像的信息量。基于对图像信息进行纹理分析后能够得到高通量的特征的特点，受基因组学以及肿瘤异质性的启发，2012年荷兰学者Lambin在先前学者工作的基础上提出了**影像组学(Radiomics) **的概念。 Radiomics: Extracting more information from medical images using advanced feature analysis Lambin认为“高通量地从医学影像中提取大量特征，通过自动或半自动分析方法将影像学数据转化为具有高分辨率的可挖掘数据空间”医学影像可以全面、无创、定量地观察肿瘤的空间和时间异质性。Kumar等又对影像组学的定义进行了拓展，影像组学是指从CT、PET或MRI等医学影像图像中高通量地提取并分析大量高级且定量的影像学特征。这个理念的提出在随后的七年迅速被越来越多的学者改进与完善。 影像组学，一共4个常见字。但4个字加在一起是啥意思？好吧，拆成“影像”和“组学”两个词来说。“影像”通常指的就是放射影像，主要包括了CT、MR影像，当然，现在也陆续有加入了PET、US影像研究。组学（Omics），专门百度了一下，通俗理解就是把与研究目标相关的所有因素综合在一起作为一个“系统”来研究。目前主要包括基因组学（Genomics），蛋白组学Proteinomics，代谢组学（Metabolomics），转录组学(transcriptomics），免疫组学（Immunomics），RNA组学(RNomics)，影像组学（Radiomics）等。 影像组学流程： 影像组学本质上来说其实是一种分析思路方法，从临床问题出发，最后回到解决的临床问题。一般分为五个主要处理步骤： 标准医学影像数据获取和筛选：数据收集前，首先需要根据明确的研究方向进行数据筛选，例如做肿瘤分型或肺炎分型的鉴别诊断，所选影像数据是否有病理或病原学检测金标准进行对照；做影像学疗效评估时，是否具有多期治疗相应的影像资料匹配等。 图像分割：指将图像分成若干个特定、具备独特属性的区域并提取感兴趣目标的技术和过程。根据研究目的的不同，图像分割的目标可以是病灶、正常参考组织或是组织解剖结构，可以是三维也可以是二维区域，影像组学随后的分析研究都围绕这些从图像内分割出来的区域进行。 特征提取：影像组学的核心步骤就是提取高通量的特征来定量分析ROI的实质属性。基于Image Biomarker Standardization Initiative (IBSI)标准[4]统计划分，常将影像组学特征分为形状特征(Shape features)、一阶统计学特征（First order statistics features）、纹理特征 (texture-basedfeatures)、高阶特征(high-order features)以及基于模型转换的特征。 机器学习：特征选择，上述通过特征提取，提取到的特征数量可能有几百到几万不等，而并不是每一个特征都与要解决的临床问题相关联；另一方面，在实践中，由于特征数量相对较多，而样本数量较少，容易导致随后的模型出现过拟合的现象，从而影响模型的准确率。特征选择是根据某些评估准则，从特征集中直接选取合适的子集，或者将原有的特征经过线性&#x2F;非线性组合，生成新的特征集，再从新特征集中选取合适的子集过程。 模型应用：针对医生具体的临床问题，在临床研究问题标签的基础上建立由上述特征筛选出来的关键特征，或进一步结合影像组学以外的特征（如临床体征、病理、基因检测数据）组合而成的预测模型。 2 影像组学方法流程及工具代码：具体影像组学的流程如下： 1，影像数据准备 2，感兴趣区域分割 3，特征提取与特征选择 4，建模分析 5，结果展示 2.1 影像数据获取不同设备厂商、同一厂商不同型号的影像设备在图像扫描和重建协议上往往存在着很大的差异，迄今为止仍然缺乏统一的采集标准规范。这就可能给包含影像组学在内的众多医工结合项目造成了潜在的影响。尽管对数据存储传输、图像勾画和算法运行速度带来诸多不便，但为了最后的建模评估步骤能达到更好的效果，仍然推荐入组分辨率更高、信息量更为丰富的薄层数据。这些数据最好具有相同（或相近）的采集参数，以尽可能降低数据质量被各种成像因素的干扰。目前，国内很多医院都开展过肿瘤的影像组学相关项目，比如肺癌、肝癌、结直肠癌等等。但随着组学科研在全国乃至世界范围内发生“内卷化”，课题总数据量和多中心研究都已经成为审稿中的决定性因素。这时，在繁杂的医院数据中，既要严控数据入组条件，同时也要满足项目所需的样本数量，只有兼顾两者才可能取得最优的效果。 此外，多模态影像组学时代的开启给医工两方面的研究者都提出了更大的挑战。数据量的成倍增加、算法工程师的影像专业背景，都可能成为项目推进的阻力。这里有非常重要的一点，要求影像医生做好数据筛选：所有的影像医工交叉项目，数据量的一大原则都是“**贵精不贵多**”——除了保留与病灶相关的必要序列外，不要有任何冗余的图像，否则会成为后续工作中非常不利的因素。至于质量不过关（如包含伪影、扫描序列不完整）、缺乏完整临床指标的样本，都是应该被排除在项目之外。 当然，你如果没有私有数据集的话，也有一些比赛公开了数据集。或者你可以用公开数据集做泛化性分析： 如： 这个项目地址公开了很多医学影像数据集。 2.2 感兴趣区域分割影像准备完毕，接下来的重要步骤是病灶ROI的勾画，从而对照影像序列，进一步开展后续的特征提取。医学图像分割经过几十年的发展，目前仍然保持了两大类别：手动&#x2F;半自动分割，以及全自动分割。 由于病灶的特质性和不规则性，手动&#x2F;半自动分割仍然是现有条件下的最佳选择，即使手动分割耗时较大，它仍然是金标准获取的唯一途径。课题中既可以采用3D Slicer、ITK-SNAP等传统分割软件，也可以尝试像Pair等新兴工具，甚至可以使用工作站日常诊断中的三维重建结果。全自动分割算法包括阈值&#x2F;区域生长、分水岭、水平集等，也有近年来非常火热的深度学习算法。 但很遗憾，尽管学术界和工业界都付出了相当大的努力，但迄今为止，仍然没有高精度、全自动的通用分割模型可以完美地应用于影像科研的日常流程和基础IT架构中，**自动分割后ROI还是要医生手动调整确认以保证项目的精度效果。** 如果当你面对大量数据集的标注时，你可以使用半自动+人工检验的方式进行金标准的制作。 或者你使用公开数据集的话，公开数据集本身就有分割标注，也不用你进行分割了。 2.3 特征提取与降维选择2.3.1 特征提取：影像组学特征由一系列传统图像特征的合集构成，既包含了一阶梯度特征（区域内统计信息）、形状特征（如形态学参数、圆形度等）、纹理特征（灰度共生矩阵、灰度区域大小矩阵、灰度游程矩阵），也包含了各种图形滤波变换后的特征，比如高斯-拉普拉斯变换、小波变换、平方根滤波等。这些特征都曾经在医学图像分析中有过较为成功的运用，而影像组学正是把高阶的图像特征聚集在一起、进一步提高分析结果质量的方法。每个影像组学特征都有着独立的计算公式，现在在网上已经可以找到丰富的特征提取工具直接调用，而无需自行学习理解公式、手动编程计算。 时下流行的时是**PyRadiomics组学工具包。使用起来方便快捷，而且是基于python。** PyRadiomics的官方文档: 具体使用代码可以参考： 【使用pyradiomics提取影像组学特征【详细】】  2.3.2 特征降维(特征选择)面对大量的特征，我们不可能对其直接进行模型构建，我们需要对数据进行降维，给数据“瘦身”，从成千上万的特征数据中获取最为有价值的特征数据。 提取完毕的影像组学特征，少则成百上千；有些“噱头”概念也会在多模态+各种图像预处理后形成高达十万数量级的特征维度；目前还有一种流行的方法是将组学特征和临床数据相互结合，以便最大化综合各种层面的信息优势。这个时候就需要采用一些特征降维和筛选的手段来对特征数目进行一定的限制，避免冗余数据影响机器学习模型的精确和稳定性。 常见的降维和筛选方法有主成分分析、相关性分析以及基于L1惩罚项的特征选择法等——其实当维度达到一定级别的时候，再增加特征对最终的结果影响已经降到很低，反而严重增加了完成组学流程的时间和空间复杂度。 2.4 建模分析：课题中需要将样本分为训练集和测试集（遵循着7:3或8:2的原则），如果是多中心课题，可以根据不同医院区分样本，以其它医院的数据做外部验证的测试集，评价建模的鲁棒性。 建模时首先使用训练集，通过学习一个函数，找到各类样本的最佳区分“界面”。常用的分类器包括了决策树、逻辑回归、随机森林、支持向量机（SVM）等。在建模过程中，为了减少过拟合和选择偏差、保证更好的模型性能，常常会引入交叉验证（Cross Validation）的方法。交叉验证将数据的训练集样本切割成若干较小子集，然后先在一个子集上做分析，而其它子集则用来做后续对此分析的验证，并确定一些模型的参数。 2.5 结果分析模型训练完毕后，再采用测试集进行组学预测结果和临床标签的对比，进行性能评估。常用于展现影像组学结果的图或数值有ROC曲线、（95%置信区间下的）AUC值、敏感度、特异度、特征贡献度、相关系数热图等。 参考：【影像组学初学者指南】  【组学浅析之通俗理解影像组学的定义】  【影像组学十周年：技术，应用与展望】 "},{"title":"SimpleITK的使用","date":"2025-05-30T07:15:53.000Z","url":"/2025/05/30/SimpleITK%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["医学图像","/tags/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/"],["医学图像预处理","/tags/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86/"]],"categories":[[" ",""]],"content":"1，前情提要SimpleITK是专门处理医学影像的软件，是ITK的简化接口，使用起来非常便捷，SimpleITK支持8种编程语言，包括c++、Python、R、Java、c#、Lua、Ruby和TCL。本文主要以python为例进行讲述。 在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中图像是一个物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有坐标、间距、方向等概念。 SimpleITK的项目地址github： 说明文档：SimpleITK Sphinx Documentation — SimpleITK 2.0rc2 documentation 2，SimpleITK基础概念参考SimpleITK文档：Fundamental Concepts — SimpleITK 2.0rc2 documentation 2.1 医学图像基础概念SimpleITK假设世界坐标系下的长度单位为mm。 世界坐标系：用于医学成像仪器的坐标系。坐标用元素是连续值的向量表示。 图像坐标系：用于表示像素点的坐标系。坐标用元素是离散值的向量表示。 Origin - 世界坐标系下，图像相对于坐标系原点的位置。 Spacing - 两个像素之间在世界坐标系下的间隔。因为图像数据以离散值存储，而像素间隔取决于成像仪器而各不相同。需要注意的是各个方向的Spacing通常是不相等的，例如(0.67777,0.67777,1.33333)，其实也就是体素的大小。 Size - 每个维度的大小。用元组表示。 Direction cosine matrix - 方向余弦矩阵。世界坐标系坐标轴对应于图像像素矩阵的方向。用一组矩阵空间内的基表示。通常每个向量形似(1,0,0).T。 这些元数据元素中的每个元素的含义在下图中可视化地说明： 2.2 通道&#x2F;Channels同自然图像格式中的通道概念。医学通道中也有通道的概念。比如使用的CT图像是单通道图像，可视化后可用灰度值表示。但是也有一些成像仪器生成的图像具有多个通道，例如RGB色彩格式，能够展现更丰富的特征，相应的占用空间也会3。（比如说，LUNA16中单个CT图像文件的大小约200MB。其纵向切片分辨率为512512，切片数为120 ~ 700，通道数为1。可以看到低分辨率下单张图像的数据量就已经很夸张了。） 2.3 空间域变换&#x2F;TransformsSimpleITK 支持两种类型的空间转换，一种具有全局（无界）空间域，可以使用各种全局2D 和3D 转换（平移、旋转、刚性、相似性、仿射… …）。另一种具有有界空间域。SimpleITK 中的点通过转换使用 TransformPoint 方法进行映射。其中包括 B 样条变形变换，通常称为自由变形，以及位移场变换。 2.4 重采样&#x2F;Resampling重采样是对图像进行采样的动作，而图像本身就是对原始连续信号的采样。可以通过重采样将改变体素的大小。虽然 SimpleITK 提供了大量的插值方法，但是最常用的两种方法是 sitkLinear 和 sitkNearestNeighbor。前者用于大多数插补任务，是精度和计算效率之间的折衷。后者用于插值表示分割的标记图像。这是唯一的插值方法，不会引入新的标签到结果。 2.5 图像配准&#x2F;Registration OverviewSimpleITK包含了一些图像配准的功能。 医学图像配准（Medical Image Registration）是指将不同的医学图像（根据定义，计算机内从像素到meta信息有任意不同之处的两张医学图像都是不同的。在现实中的定义则是两次不同成像过程产生的图像。）进行对齐和匹配。医学图像配准的目标是将两个或多个医学图像进行对齐，使它们共享相同的解剖结构、几何形状和空间定位信息，从而实现它们之间的定量比较、分析和整合。常用的医学图像配准方法包括基于特征的方法、基于强度的方法、基于形变场的方法等。简单地说，来自于同一个病人的两张图像可能各自含有一些对方没有的重要信息，图像配准技术的目标是能够同时利用这两张图象的信息。如果两张图象来自于不同原理的成像仪器（例如CT和MRI），这种图像配准技术被称作跨模态图像配准（Cross-Modality Image Registration）&#x2F;多模态图像配准（Multimodal Image Registration）。跨模态指的是A-&gt;B或B-&gt;A，多模态则是指任何涉及到多个模态的问题环境。可能是因为原始图像采样过程中丢失了精度，或者数学上两张不同的医学图像本身就不可能完全重叠？在图像配准任务中，实现的过程用估计（estimate）来表述。图像配准最基本的过程包含了坐标轴位移、旋转、拉伸等操作。用SimpleITK完成图像配准工作需要Transformation、Similarity metric、Optimizer、Interpolator这四个工具共同实现。配准更具体细节参考：Registration Overview — SimpleITK 2.4.0 documentation 3，SimpleITK的基本使用3.1 安装与常见属性在这里，使用python对SimpleITK库中常用的函数进行举例说明： 在使用SimpleITK库之前，需要将SimpleITK库导入进来，如下： 3.1.1 sitk中的常见属性值sitk中有以下四种常见的属性，分别可以使用get的方式获取，代码如下所示： 举例说明：以二维图像为例，左下图是世界坐标系，右下图是图像坐标系。属性值如下所示 3.2 读取和保存图像SimpleITK可以读取如.mhd , .nii, .nrrd等图像数据格式。 Note1：图像访问是以x， y， z顺序GetPixel(x,y,z) 或 **image[x,y,z]**， 从0开始索引。 Note2：默认的mask图像类型和默认值为sitkUInt8或标量图像uint8_t， 默认值为0和1，其中1代表的是mask。 使用SimpleITK读取和保存Nii.gz文件: 3.3 像素类型像素类型表示为枚举类型，下面是部分枚举类型的表。 还有sitkUnknown类型，用于未定义或错误的像素ID，值为-1。 Note：64位整数类型并非在所有的发行版上都可用，如果不可用，则值为sitkUnknown，将图像保存为nii文件，用ITKsnap读取时就会出现的错误如下： 3.4 SimpleITK图像数据和Numpy矩阵数据之间的转换一般我们会用SimpleITK读取图像，再转换为numpy矩阵格式，这样方便数据的处理。 Note1：在SimpleITK中，各术语对应如下： Width: 宽度，X轴，矢状面（Sagittal） Height: 高度，Y轴，冠状面（Coronal） Depth: 深度， Z轴，横断面（Axial） Note2: SimpleITK图像顺序是x，y，z三个方向的大小（在第一节中也讲过），而numpy矩阵的顺序是z，y，x三个方向的大小, 要注意索引位置。 举个例子：假设实验用的图片大小为32025080，即矢状面（x轴方向）切片数为320，冠状面（y轴方向）切片数为250，横断面（z轴方向）片数为80。 3.4.1 SimpleITK2Numpy:GetArrayFromImage()：返回图像数据的副本。然后可以自由地修改数据，因为它对原始SimpleITK图像没有影响。 3.4.2 Numpy2SimpleITK：GetImageFromArray()：返回一个SimpleITK图像，原点设置为0，所有维度的间距设置为1，方向余弦矩阵设置为identity，强度数据从numpy数组中复制。在大多数情况下需要设置适当的元数据值。 Note: 从array转成image需要设置原点，维度间距以及方向。 3.5 访问像素和切片两种方式：一是使用GetPixel和SetPixel函数，二是使用python的切片操作符。例子如下： 3.6 图像重采样重采样目的是将医疗图像中不同的体素归一化到相同的大小，可分为两种方案， 方案一：按目标Spacing缩放 方案二：按目标Size缩放。 这两种方案具体操作分为三个步骤： 使用SimpleITK读取数据，获得原始图像的Spacing以及Size； 如果是方案一，则图像原始Size乘以原始Spacing除以新Spacing得到新Size，如果是方案二，则图像原始Size乘以原始Spacing除以新Size得到新Spacing； 最后将新Spacing和新Size赋值到读取的数据即可。 下面以指定Spacing大小，对原始数据进行重采样，例子如下： 3.7 图像分割图像二值化分割： 是分割方法中最基础的，通过定义lowerThreshold和upperThreshold两个像素临界点，只要像素值在两者之间，则该像素值改为insideValue，否则改为outsideValue。这种方法只是简单的基于灰度范围标记图像像素，不考虑几何或连通性。 图像区域生长分割： 需要确定种子点、生长准则和终止条件。具体来说，对每一个需要分割的区域找一个种子像素作为生长的起点，根据生长准则将种子像素邻域中与种子像素具有相同或相似的像素合并到种子像素所在的区域，直到没有满足条件的像素可以被包进来就终止。 在SimpleITK中，首先会计算当前区域中包含的所有像素点灰度值的标准差和期望，通过定义multiplier因子（乘以标准差）来计算以期望为中心的灰度值范围，如果initialNeighborhoodRadius邻域半径内的灰度值位于这个范围就被包进来，灰度值改为replaceValue，当遍历了所有邻域像素，即认为完成了一次迭代，下一次迭代时，像素点的灰度值期望和标准差是以新的像素区域为基础进行计算的，一共要迭代numberOfIterations次。 3.8 图像的形态学操作图像形态学操作一般常用的是开，闭，膨胀，腐蚀操作： 3.9 连通域分析连通域分析一般是针对二值图像，将具有相同像素值且相邻的像素找出来并标记，其中二维图像连通域一般包括4连通和8连通，三维图像连通域包括6连通、18连通和26连通。 4 参考SimpleITK Sphinx Documentation — SimpleITK 2.0rc2 documentation  SimpleITK图像基础（三）——SimpleITK学习笔记_Jiaxxxxxx的博客-CSDN博客 SimpleITK的使用"},{"title":"test1","date":"2025-05-30T07:05:52.000Z","url":"/2025/05/30/test1/","categories":[[" ",""]],"content":"这是图片测试： "},{"title":"Hello World","date":"2025-05-18T12:49:22.161Z","url":"/2025/05/18/hello-world/","categories":[[" ",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]